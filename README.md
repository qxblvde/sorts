## 1. Insertion Sort

Insertion sort - это простой алгоритм сортировки, который работает, как люди сортируют карты в руках. Он последовательно берет каждый элемент из неотсортированной части и вставляет его на нужное место в отсортированной части массива.

```c++
void InsertionSort(int arr[],int n) {
    for (int i = 1; i < n;i++) {
        int key = arr[i];
        int j = i-1;
        while (j >= 0 && arr[j] > key) {
            arr[j+1] = arr[j];
            j--;
        }
        arr[j+1] = key;

    }
}
```

### Асимптотика по времени:

Лучший случай: когда все элементы частично/полностью отсортированы, **O(n)**, тк просто фором пройдем все элементы и будем заходить в вайл супер редко.

Средний и худший случаи: **O(n^2)**, тк зайдем в вайл и будем перебирать элементы в отсортированном массиве

### Асимптотика по памяти:

Все случаи: O(1), тк работаем только с переменными

### Устойчивость:

Устойчивая

### Когда использовать:

Когда массивы частично/полностью отсортированы, тк время выполнения будет меньше, чем у Merge/Quick Sort

Когда данные поступают в режиме реального времени и нужно поддерживать массив в отсортированном состоянии по мере поступления новых элементов. Каждый новый элемент можно легко вставить на нужное место, не требуя полной перестановки массива

### Инвариант:

Первые i - 1 элементов отсортированы





## 2. Merge Sort

Merge Sort (сортировка слиянием) — это эффективный алгоритм сортировки, который работает по принципу «разделяй и властвуй». Он рекурсивно делит массив на меньшие подмассивы, сортирует каждый из них, а затем объединяет их обратно, чтобы получить отсортированный массив.

```c++
void merge(int *arr, int left, int mid, int right) {
    int it1 = 0;
    int it2 = 0;
    int result[right - left];
    long long cnt = 0;
    while (left + it1 < mid && mid + it2 < right) {
        if (arr[left + it1] <= arr[mid + it2]) {
            result[it1 + it2] = arr[left + it1];
            it1 += 1;
        } else {
            result[it1 + it2] = arr[mid + it2];
            it2+=1;
        }

    }
    while (left + it1 < mid) {
        result[it1 + it2] = arr[left + it1];
        it1+=1;
    }
    while (mid + it2 < right) {
        result[it1 + it2] = arr[mid + it2];
        it2+=1;
    }
    for (int i = 0; i < (it1 + it2); i++) {
        arr[left + i] = result[i];
    }

}

void mergeSortRecursive(int *arr, int left, int right) {
    if (left + 1 >= right) {
        return;
    }
    int mid = (left + right) / 2;
    mergeSortRecursive(arr, left, mid);
    mergeSortRecursive(arr, mid, right);
    merge(arr, left, mid, right);
}
```

### Асимптотика по времени:

Все случаи: O(n * log(n)), тк независимо от массива мы всегда разбиваем его на 2 равные части за log(n), а сливаем в один за n, тк при первом слиянии все элементы разбиты на массивы с размером 1

### Асимптотика по памяти:

Все случаи: O(n) на создание вспомогательного массива размером n элементов

### Устойчивость:

Устойчивая, т.е элементы с одинаковыми значениями сохранят свой порядок относительно друг друга.

### Когда использовать:

Когда требуется стабильная по асимптотике сортировка, когда важен порядок одинаковых элементов, т.к сортировка устойчивая

### Инвариант:

При слиянии двух массивов элементы в каждом массиве отсортированны

## Quick Sort:

Quick Sort (быстрая сортировка) — это популярный алгоритм сортировки, работающий по принципу разделяй и властвуй. Он выбирает опорный элемент (pivot), делит массив на две части относительно этого опорного элемента и рекурсивно сортирует каждую из частей. Это делает его одним из самых эффективных алгоритмов для сортировки массивов и списков на практике.

### Разбиение Хоара(быстрее чем Ломуто, так как происходит примерно в 3 раза меньше свапов. В Хоара pivot - элемент в середине массива)
```c++
void quicksort(int* arr, int &l, int &r){
    int i = l;
    int j = r;
    int pivot = arr[l+rand()%(r-l+1)];
    while (i<=j) {
        while (arr[i] < pivot) {
            i++;
        }
        while (arr[j] > pivot) {
            j--;
        }
        if(i<=j) {
            swap(arr[i], arr[j]);
            i++;
            j--;
        }

    }
    if (l < j) {
        quicksort(arr, l, j);
    }
    if (r > i) {
        quicksort(arr, i, r);
    }
}
```


### Асимптотика по времени:

Лучший и средний случаи: O(n * log(n)), лучший и средний случай происходят тогда, когда опорный элемент pivot выбирает серидинный элемент по значению и массив делится на две примерно равные части. n на перебор всех элементов, log(n) на глубину рекурсии

Худший случай: O(n^2), log(n) превращается в n, ведь при худшем случае массив будет делиться на две неравные части, например массив из 5 элементов поделится на 1 и 4.

### Асимптотика по памяти:

Лучший и средний случаи: O(log(n)) на глубину рекурсии

Худший случай: O(n) на глубину рекурсии

### Устойчивость:

Неустойчивая

### Когда использовать:

Когда требуется использовать как можно меньше памяти, т.к квик сорт требует гораздо меньше памяти, чем мердж или сортировка вставками.

### Инвариант:

Слева от pivot элементы меньше pivot, а справа больше или равны pivot

### Способы вычислить pivot:

Рандомный элемент (менторы не рекомендуют)

Средний элемент

Медиана трех

Медиана медиан массивов из 5 элементов

## Counting Sort

Counting Sort — это алгоритм сортировки, который использует прямой подсчёт для сортировки элементов. Этот алгоритм подходит для сортировки массивов целых чисел в определённом диапазоне значений. Counting Sort эффективен для сортировки целых чисел и не зависит от операций сравнения между элементами, как многие другие алгоритмы сортировки.

```c++
vector<int> countSort(vector<int>& inputArray) {

    int N = inputArray.size();
    int M = 0;
    for (int i = 0; i < N; i++)
        M = max(M, inputArray[i]);
    vector<int> countArray(M + 1, 0);

    for (int i = 0; i < N; i++)
        countArray[inputArray[i]]++;
    for (int i = 1; i <= M; i++)
        countArray[i] += countArray[i - 1];
    vector<int> outputArray(N);
    for (int i = N - 1; i >= 0; i--)
    {
        outputArray[countArray[inputArray[i]] - 1]
            = inputArray[i];

        countArray[inputArray[i]]--;
    }

    return outputArray;
}
```

### Асимптотика по времени:

Все случаи: O(n)/O(n + k), где k - диапазон чисел

### Асимптотика по памяти:

Все случаи: O(n)/O(n + k), где k - диапазон чисел

### Устойчивость

Устойчивая

### Когда использовать

Count Sort лучше использовать при небольшом диапазоне значений. Например, при массиве из 1000 элементов со значениями 0-100 каунт сорт будет очень эффективным

### Инвариант

На каждом шаге построения выходного массива все элементы, которые имеют значения меньше текущего значения, уже правильно размещены в выходном массиве.
