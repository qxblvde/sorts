## 1. Insertion sort

Insertion sort - это простой алгоритм сортировки, который работает, как люди сортируют карты в руках. Он последовательно берет каждый элемент из неотсортированной части и вставляет его на нужное место в отсортированной части массива.

```c++
void InsertionSort(int arr[],int n) {
    for (int i = 1; i < n;i++) {
        int key = arr[i];
        int j = i-1;
        while (j >= 0 && arr[j] > key) {
            arr[j+1] = arr[j];
            j--;
        }
        arr[j+1] = key;

    }
}
```

### Асимптотика по времени:

Лучший случай: когда все элементы частично/полностью отсортированы, **O(n)**, тк просто фором пройдем все элементы и будем заходить в вайл супер редко.

Средний и худший случаи: **O(n^2)**, тк зайдем в вайл и будем перебирать элементы в отсортированном массиве

### Асимптотика по памяти:

Все случаи: O(n), тк работаем только с переменными

### Устойчивость:

Устойчивая

### Когда использовать:

Когда массивы частично/полностью отсортированы, тк время выполнения будет меньше, чем у Merge/Quick Sort

Когда данные поступают в режиме реального времени и нужно поддерживать массив в отсортированном состоянии по мере поступления новых элементов. Каждый новый элемент можно легко вставить на нужное место, не требуя полной перестановки массива

### Инвариант:

Первые i элементов отсортированы





## 2. Merge sort

Merge Sort (сортировка слиянием) — это эффективный алгоритм сортировки, который работает по принципу «разделяй и властвуй». Он рекурсивно делит массив на меньшие подмассивы, сортирует каждый из них, а затем объединяет их обратно, чтобы получить отсортированный массив.

```c++
void merge(int *arr, int left, int mid, int right) {
    int it1 = 0;
    int it2 = 0;
    int result[right - left];
    long long cnt = 0;
    while (left + it1 < mid && mid + it2 < right) {
        if (arr[left + it1] <= arr[mid + it2]) {
            result[it1 + it2] = arr[left + it1];
            it1 += 1;
        } else {
            result[it1 + it2] = arr[mid + it2];
            it2+=1;
        }

    }
    while (left + it1 < mid) {
        result[it1 + it2] = arr[left + it1];
        it1+=1;
    }
    while (mid + it2 < right) {
        result[it1 + it2] = arr[mid + it2];
        it2+=1;
    }
    for (int i = 0; i < (it1 + it2); i++) {
        arr[left + i] = result[i];
    }

}

void mergeSortRecursive(int *arr, int left, int right) {
    if (left + 1 >= right) {
        return;
    }
    int mid = (left + right) / 2;
    mergeSortRecursive(arr, left, mid);
    mergeSortRecursive(arr, mid, right);
    merge(arr, left, mid, right);
}
```

### Асимптотика по времени:

Все случаи: O(n * log(n)), тк независимо от массива мы всегда разбиваем его на 2 равные части за log(n), а сливаем в один за n, тк при первом слиянии все элементы разбиты на массивы с размером 1

### Асимптотика по памяти:

Все случаи: O(n) на создание вспомогательного массива размером n элементов

### Устойчивость:

Устойчивая, т.е элементы с одинаковыми значениями сохранят свой порядок относительно друг друга.

### Когда использовать:

Когда требуется стабильная по асимптотике сортировка, когда важен порядок одинаковых элементов, т.к сортировка устойчивая

